; N-body simulation based on the one from Futhark:
; https://github.com/diku-dk/futhark-benchmarks/tree/master/accelerate/nbody
; which is based on the one from Accelerate:
; https://github.com/AccelerateHS/accelerate-examples/tree/master/examples/n-body

(let ((type &mass Float)
      (type *position [Float 3])
      (type *acceleration [Float 3])
      (type *velocity [Float 3])
      ((dot ((x [Float 3]) (y [Float 3])) : Float)
       (@reduce Float (2 []) f.+ (f.* x y))
        )
      ((vec-+ ((x [Float 3]) (y [Float 3])) : [Float 3])
       (f.+ x y)
       )
      ((accel ((epsilon Float)
               (x_pos *position)
               (x_mass &mass)
               (y_pos *position)
               (y_mass &mass)
               ) : *acceleration)
       (let ((r (f.- x_pos y_pos))
             (rsqr  (f.+ (dot r r) (f.* epsilon epsilon)))
             (invr  (f./ 1.0 (sqrt rsqr)))
             (invr3  (f.* (f.* invr invr) invr))
             (s  (f.* y_mass invr3))
             )
         (f.* s r)))
      ((advance_pos ((time_step Float)
                     (position *position)
                     (velocity *velocity)
                     ) : *position)
       (f.+ position (f.* time_step velocity)))
      ((advance_vel ((time_step Float)
                     (velocity *velocity)
                     (acceleration *acceleration)
                     ) : *velocity)
       (f.+ velocity (f.* time_step acceleration )))
      ((@calc_accels _ $n
                     ((epsilon Float)
                      ;; it would be nice to be able to write [*position (+ $n 1)]
                      (positions [Float (+ $n 1) 3])
                      (masses [Float (+ $n 1)])
                      ) : [Float (+ $n 1) 3])
       (let (((compute_accels ((position *position)
                              (mass &mass)
                              ) : [Float (+ $n 1) 3])
              (accel epsilon position mass positions masses))
              ((move ((position *position)
                     (mass &mass)
                     ) : *acceleration)
              (let (accels (compute_accels position mass))
                (@reduce Float ($n [3]) vec-+ accels)))
             )
           (move positions masses)
         )))
  (@calc_accels _ 0 1.0 [[1.0 2.0 3.0]] [1.0])
  )
